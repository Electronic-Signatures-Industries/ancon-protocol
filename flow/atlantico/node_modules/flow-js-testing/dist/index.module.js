import{flowConfig as e}from"@onflow/fcl-config";import{config as n}from"@onflow/config";import t from"fs";import r from"path";import*as o from"@onflow/types";import*as c from"@onflow/fcl";import{mapValuesToCode as s,getEnvironment as a,reportMissingImports as i,replaceImportAddresses as u,reportMissing as l,sendTransaction as f,extractContractParameters as m,generateSchema as d,splitArgs as g,deployContract as h,executeScript as p}from"flow-cadut";import{ec as P}from"elliptic";import{SHA3 as v}from"sha3";import*as M from"rlp";const A=(e,n,t)=>{if("string"==typeof n)return A(e,n.split("/"),t);if(!n.length)return e;try{const[r,...o]=n;return A(e[r],o,t)}catch(e){return t}},b=(t,r,o,c)=>{let s=A(e(),o,c);s||(s=c),n().put(t,s)},y=function(e){try{return Promise.resolve(n().get(e))}catch(e){return Promise.reject(e)}},k=function(e,t={}){try{const{port:r=8080}=t,{pkey:o="48a1f554aeebf6bf9fe0d7b5b79d080700b073ee77909973ea0b2f6fbc902"}=t;return b("PRIVATE_KEY",process,"accounts/emulator-account/key",o),b("SERVICE_ADDRESS",process,"accounts/emulator-account/address","f8d6e0586b0a20c7"),b("BASE_PATH",process,"testing/paths",e),n().put("accessNode.api",`http://localhost:${r}`),Promise.resolve()}catch(e){return Promise.reject(e)}},w=e=>null==e?null:e.replace(/^0x/,""),x=e=>null==e?null:"0x"+w(e),S=new P("p256"),T=(e,n)=>{const t=S.keyFromPrivate(Buffer.from(e,"hex")).sign((e=>{const n=new v(256);return n.update(Buffer.from(e,"hex")),n.digest()})(n)),r=t.r.toArrayLike(Buffer,"be",32),o=t.s.toArrayLike(Buffer,"be",32);return Buffer.concat([r,o]).toString("hex")},F=(e,t=0)=>function(r={}){try{return Promise.resolve(n().get("SERVICE_ADDRESS")).then(function(o){return Promise.resolve(n().get("PRIVATE_KEY")).then(function(n){return e=w(e||o),{...r,tempId:`${e}-${t}`,addr:c.sansPrefix(e),keyId:t,signingFunction:function(r){try{return Promise.resolve({keyId:t,addr:x(e),signature:T(n,r.message)})}catch(e){return Promise.reject(e)}}}})})}catch(e){return Promise.reject(e)}},j=e=>"object"==typeof e&&null!==e;function E(e,n,t){if(!e.s){if(t instanceof B){if(!t.s)return void(t.o=E.bind(null,e,n));1&n&&(n=t.s),t=t.v}if(t&&t.then)return void t.then(E.bind(null,e,n),E.bind(null,e,2));e.s=n,e.v=t;const r=e.o;r&&r(e)}}const B=function(){function e(){}return e.prototype.then=function(n,t){const r=new e,o=this.s;if(o){const e=1&o?n:t;if(e){try{E(r,1,e(this.v))}catch(e){E(r,2,e)}return r}return this}return this.o=function(e){try{const o=e.v;1&e.s?E(r,1,n?n(o):o):t?E(r,1,t(o)):E(r,2,o)}catch(e){E(r,2,e)}},r},e}(),C=(e,n)=>{if(0===e.length)return[];const[t]=e;return Array.isArray(t)&&t[t.length-1].asArgument?(e=>e.reduce((e,n)=>[...e,...((e,n)=>{const t=e[e.length-1];return e.slice(0,-1).map(e=>((e,n)=>c.arg(e,n))(e,t))})(n)],[]))(e):s(n,e)},I=e=>function(n){try{function t(){function e(){return Promise.resolve(me()).then(function(e){function t(){return{code:r,signers:c,args:s,limit:u}}const o={...xe,...n,FlowManager:e};r=ke(r,o);const a=function(e,n,t){var o=[];for(var c in e)o.push(c);return function(e,n,t){var r,o,c=-1;return function t(s){try{for(;++c<e.length;)if((s=n(c))&&s.then){if(!((a=s)instanceof B&&1&a.s))return void s.then(t,o||(o=E.bind(null,r=new B,2)));s=s.v}r?E(r,1,s):r=s}catch(e){E(r||(r=new B),2,e)}var a}(),r}(o,function(e){return function(e){return Promise.resolve((0,i[e])(r)).then(function(e){r=e})}(o[e])})}(i);return a&&a.then?a.then(t):t()})}let n;const t=function(){if(!a)return Promise.resolve(we(r)).then(function(e){n=e});n=xe}();return t&&t.then?t.then(e):e()}let r,o,c,s,a,i,u;if(j(n[0])){const[e]=n,{name:t,code:l,args:f,signers:m,transformers:d,limit:g=999,service:h=!1}=e;if(a=h,!t&&!l)throw Error("Both `name` and `code` are missing. Provide either of them");o=t,r=l,c=m,s=f,i=d||[],u=g}else"script"===e?[o,s,i]=n:[o,c,s,i]=n;const l=function(){if(o)return Promise.resolve(("script"===e?Be:Ee)({name:o})).then(function(e){r=e})}();return Promise.resolve(l&&l.then?l.then(t):t())}catch(e){return Promise.reject(e)}},R=function(){try{const e=arguments,n=I("tx");return Promise.resolve(n([].slice.call(e))).then(function({code:e,args:n,signers:t,limit:r}){const o=F(),s=[c.transaction(e),c.payer(o),c.proposer(o),c.limit(r)];if(t){const e=t.map(e=>F(e));s.push(c.authorizations(e))}else s.push(c.authorizations([o]));return n&&s.push(c.args(C(n,e))),Promise.resolve(c.send(s)).then(function(e){return Promise.resolve(c.tx(e).onceExecuted())})})}catch(e){return Promise.reject(e)}},O=function(){try{const e=arguments,n=I("script");return Promise.resolve(n([].slice.call(e))).then(function({code:e,args:n,limit:t}){const r=[c.script(e),c.limit(t)];return n&&r.push(c.args(C(n,e))),Promise.resolve(c.send(r)).then(function(e){return c.decode(e)})})}catch(e){return Promise.reject(e)}},U="\n  import FlowManager from 0x01\n\ntransaction (_ name: String, pubKey: String, manager: Address) {\n    prepare( admin: AuthAccount) {\n        let newAccount = AuthAccount(payer:admin)\n        newAccount.addPublicKey(pubKey.decodeHex())\n\n        let linkPath = FlowManager.accountManagerPath\n        let accountManager = getAccount(manager)\n                            .getCapability(linkPath)!\n                            .borrow<&FlowManager.Mapper>()!\n        \n        // Create a record in account database\n        let address = newAccount.address\n        accountManager.setAddress(name, address: address)\n    }\n}\n\n",$=function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(U,t,"createAccount =>"),u(U,t)})}catch(e){return Promise.reject(e)}},_="\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        acct.contracts.add(\n           name: name,\n           code: decoded,\n           ##ARGS-LIST##\n        )\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",D=function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(_,t,"deployContract =>"),u(_,t)})}catch(e){return Promise.reject(e)}},L='\n  transaction ( code: String ) {\n    prepare( admin: AuthAccount) {\n        admin.contracts.add(\n           name: "FlowManager",\n           code: code.decodeHex(),\n        )\n   }\n  }\n',H=function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(L,t,"initManager =>"),u(L,t)})}catch(e){return Promise.reject(e)}},G='\n  import FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\ntransaction(recipient: Address, amount: UFix64) {\n    let tokenAdmin: &ExampleToken.Administrator\n    let tokenReceiver: &{FungibleToken.Receiver}\n\n    prepare(signer: AuthAccount) {\n        self.tokenAdmin = signer\n        .borrow<&ExampleToken.Administrator>(from: /storage/exampleTokenAdmin)\n        ?? panic("Signer is not the token admin")\n\n        self.tokenReceiver = getAccount(recipient)\n        .getCapability(/public/exampleTokenReceiver)!\n        .borrow<&{FungibleToken.Receiver}>()\n        ?? panic("Unable to borrow receiver reference")\n    }\n\n    execute {\n        let minter <- self.tokenAdmin.createNewMinter(allowedAmount: amount)\n        let mintedVault <- minter.mintTokens(amount: amount)\n\n        self.tokenReceiver.deposit(from: <-mintedVault)\n\n        destroy minter\n    }\n}\n\n',K=function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(G,t,"mintTokens =>"),u(G,t)})}catch(e){return Promise.reject(e)}},V="\n  import FlowManager from 0x01\n\ntransaction(name: String, address: Address) {\n    prepare(signer: AuthAccount){\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = signer\n                                .getCapability(linkPath)!\n                                .borrow<&FlowManager.Mapper>()!\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",z=function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(V,t,"registerContract =>"),u(V,t)})}catch(e){return Promise.reject(e)}},N="\n  transaction{\n    prepare(acct: AuthAccount){\n        log(acct.address)\n    }\n}\n",Y=function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(N,t,"scratch =>"),u(N,t)})}catch(e){return Promise.reject(e)}},W="\n  import FlowManager from 0x01\n\ntransaction(offset: UInt64){\n    prepare(signer:AuthAccount){\n        FlowManager.setBlockOffset(offset)\n    }\n}\n\n",q=function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(W,t,"setBlockOffset =>"),u(W,t)})}catch(e){return Promise.reject(e)}},J="\n  import FlowManager from 0x01\n\ntransaction(name:String, code: String, manager: Address ##ARGS-WITH-TYPES##) {\n    prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n\n        if acct.contracts.get(name: name) == nil {\n          acct.contracts.add(name: name, code: decoded)\n        } else {\n          acct.contracts.update__experimental(name: name, code: decoded)\n        }\n\n        let linkPath = FlowManager.contractManagerPath\n        let contractManager = getAccount(manager)\n                    .getCapability(linkPath)!\n                    .borrow<&FlowManager.Mapper>()!\n\n        let address = acct.address\n        contractManager.setAddress(name, address: address)\n    }\n}\n\n",Q=function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(J,t,"updateContract =>"),u(J,t)})}catch(e){return Promise.reject(e)}};var X={createAccountTemplate:$,createAccount:function(e){try{const{addressMap:n,args:t=[],signers:r=[]}=e;return Promise.resolve($(n)).then(function(n){return l("arguments",t.length,3,"createAccount =>"),l("signers",r.length,1,"createAccount =>"),f({code:n,...e})})}catch(e){return Promise.reject(e)}},deployContractTemplate:D,deployContract:function(e){try{const{addressMap:n,args:t=[],signers:r=[]}=e;return Promise.resolve(D(n)).then(function(n){return l("arguments",t.length,3,"deployContract =>"),l("signers",r.length,1,"deployContract =>"),f({code:n,...e})})}catch(e){return Promise.reject(e)}},initManagerTemplate:H,initManager:function(e){try{const{addressMap:n,args:t=[],signers:r=[]}=e;return Promise.resolve(H(n)).then(function(n){return l("arguments",t.length,1,"initManager =>"),l("signers",r.length,1,"initManager =>"),f({code:n,...e})})}catch(e){return Promise.reject(e)}},mintTokensTemplate:K,mintTokens:function(e){try{const{addressMap:n,args:t=[],signers:r=[]}=e;return Promise.resolve(K(n)).then(function(n){return l("arguments",t.length,2,"mintTokens =>"),l("signers",r.length,1,"mintTokens =>"),f({code:n,...e})})}catch(e){return Promise.reject(e)}},registerContractTemplate:z,registerContract:function(e){try{const{addressMap:n,args:t=[],signers:r=[]}=e;return Promise.resolve(z(n)).then(function(n){return l("arguments",t.length,2,"registerContract =>"),l("signers",r.length,1,"registerContract =>"),f({code:n,...e})})}catch(e){return Promise.reject(e)}},scratchTemplate:Y,scratch:function(e){try{const{addressMap:n,args:t=[],signers:r=[]}=e;return Promise.resolve(Y(n)).then(function(n){return l("arguments",t.length,0,"scratch =>"),l("signers",r.length,1,"scratch =>"),f({code:n,...e})})}catch(e){return Promise.reject(e)}},setBlockOffsetTemplate:q,setBlockOffset:function(e){try{const{addressMap:n,args:t=[],signers:r=[]}=e;return Promise.resolve(q(n)).then(function(n){return l("arguments",t.length,1,"setBlockOffset =>"),l("signers",r.length,1,"setBlockOffset =>"),f({code:n,...e})})}catch(e){return Promise.reject(e)}},updateContractTemplate:Q,updateContract:function(e){try{const{addressMap:n,args:t=[],signers:r=[]}=e;return Promise.resolve(Q(n)).then(function(n){return l("arguments",t.length,3,"updateContract =>"),l("signers",r.length,1,"updateContract =>"),f({code:n,...e})})}catch(e){return Promise.reject(e)}}};const{updateContractTemplate:Z,deployContractTemplate:ee}=X,ne=e=>Buffer.from(e,"utf8").toString("hex"),te=function(e){try{let n,t,r,o,c;if(j(e[0])){const[s]=e,{name:a,to:i,addressMap:u,args:l,update:f}=s;if(!a)throw Error("'name' field is missing");n=a,t=i,o=l,r=u,c=f}else[n,t,r,o,c]=e;return Promise.resolve(me()).then(function(e){const s={...xe,FlowManager:e,...r};return{name:n,to:t,args:o,update:c,addressMap:s}})}catch(e){return Promise.reject(e)}},re=function(){try{return Promise.resolve(te([].slice.call(arguments))).then(function(e){function n(e){return Promise.resolve(je({name:r,addressMap:o})).then(function(n){return oe({to:e,code:n,name:r,args:c,update:s})})}const{to:t,name:r,addressMap:o,args:c,update:s=!1}=e;return t?n(t):Promise.resolve(me()).then(n)})}catch(e){return Promise.reject(e)}},oe=function(e){try{function n(e){return Promise.resolve(me()).then(function(n){const t=ne(r),a={FlowManager:n};return Promise.resolve(s?Z(a):ee(a)).then(function(s){let a=[o,t,n];return Promise.resolve(m(r)).then(function(n){if(c){a=a.concat(c);const e=d(n.args).map(e=>g(e)[0]),t="abcdefghijklmnopqrstuvwxyz";let r=[];for(let n=0;n<e.length;n++)r.push(`${t[n]}: ${e[n]}`);s=(s=s.replace("##ARGS-WITH-TYPES##",`, ${n.args}`)).replace("##ARGS-LIST##",r)}else s=(s=s.replace("##ARGS-WITH-TYPES##","")).replace("##ARGS-LIST##","");return R({code:s,args:a,signers:[e]})})})})}const{to:t,code:r,name:o,args:c,update:s}=e;return Promise.resolve(t?n(t):Promise.resolve(me()).then(n))}catch(e){return Promise.reject(e)}},ce='\n  pub contract FlowManager {\n\n    /// Account Manager\n    pub event AccountAdded(address: Address)\n\n    pub struct Mapper {\n        pub let accounts: {String: Address}\n\n        pub fun getAddress(_ name: String): Address? {\n            return self.accounts[name]\n        }\n\n        pub fun setAddress(_ name: String, address: Address){\n            self.accounts[name] = address\n            emit FlowManager.AccountAdded(address: address)\n        }\n\n        init(){\n            self.accounts = {}\n        }\n    }\n\n    pub fun getAccountAddress(_ name: String): Address?{\n        let accountManager = self.account\n            .getCapability(self.accountManagerPath)\n            .borrow<&FlowManager.Mapper>()!\n\n        return accountManager.getAddress(name)\n    }\n\n    pub let defaultAccounts: {Address : String}\n\n    pub fun resolveDefaultAccounts(_ address: Address): Address{\n        let alias = self.defaultAccounts[address]!\n        return self.getAccountAddress(alias)!\n    }\n\n    pub let accountManagerStorage: StoragePath\n    pub let contractManagerStorage: StoragePath\n    pub let accountManagerPath: PublicPath\n    pub let contractManagerPath: PublicPath\n\n    /// Environment Manager\n    pub event BlockOffsetChanged(offset: UInt64)\n\n    pub struct MockBlock {\n        pub let id: [UInt8; 32]\n        pub let height: UInt64\n        pub let view: UInt64\n        pub let timestamp: UFix64\n\n        init(_ id: [UInt8; 32], _ height: UInt64, _ view: UInt64, _ timestamp: UFix64){\n            self.id = id\n            self.height = height\n            self.view = view\n            self.timestamp = timestamp\n        }\n    }\n\n    pub fun setBlockOffset(_ offset: UInt64){\n        self.blockOffset = offset\n        emit FlowManager.BlockOffsetChanged(offset: offset)\n    }\n\n    pub fun getBlockHeight(): UInt64 {\n        var block = getCurrentBlock()\n        return block.height + self.blockOffset\n    }\n\n    pub fun getBlock(): MockBlock {\n        var block =  getCurrentBlock()\n        let mockBlock = MockBlock(block.id, block.height, block.view, block.timestamp);\n        return mockBlock\n    }\n\n    pub var blockOffset: UInt64;\n\n\n    // Initialize contract\n    init(){\n        // Environment defaults\n        self.blockOffset = 0;\n\n        // Account Manager initialization\n        let accountManager = Mapper()\n        let contractManager = Mapper()\n\n        self.defaultAccounts = {\n          0x01: "Alice",\n          0x02: "Bob",\n          0x03: "Charlie",\n          0x04: "Dave",\n          0x05: "Eve"\n        }\n\n        self.accountManagerStorage = /storage/testSuitAccountManager\n        self.contractManagerStorage = /storage/testSuitContractManager\n\n        self.accountManagerPath = /public/testSuitAccountManager\n        self.contractManagerPath = /public/testSuitContractManager\n        \n        // Destroy previously stored values\n        self.account.load<Mapper>(from: self.accountManagerStorage)\n        self.account.load<Mapper>(from: self.contractManagerStorage)\n\n        self.account.save(accountManager, to: self.accountManagerStorage)\n        self.account.save(contractManager, to: self.contractManagerStorage)\n\n        self.account.link<&Mapper>(self.accountManagerPath, target: self.accountManagerStorage)\n        self.account.link<&Mapper>(self.contractManagerPath, target: self.contractManagerStorage)\n    }\n}\n \n',se="\n  import FlowManager from 0x01\n\npub fun main(){\n    // the body can be empty, cause script will throw error if FlowManager is not\n    // added to service address\n}\n\n",ae="\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.accountManagerPath\n    let accountManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return accountManager.getAddress(name)\n\n}\n",ie='\n  // This script reads the balance field of an account\'s FlowToken Balance\n\nimport FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport ExampleToken from 0xTOKENADDRESS\n\npub fun main(account: Address): UFix64 {\n    let acct = getAccount(account)\n    let vaultRef = acct.getCapability(/public/exampleTokenBalance)!.borrow<&ExampleToken.Vault{FungibleToken.Balance}>()\n        ?? panic("Could not borrow Balance reference to the Vault")\n\n    return vaultRef.balance\n}\n',ue="\n  import FlowManager from 0x01\n\npub fun main():UInt64 {\n    return FlowManager.blockOffset\n}\n\n",le="\n  import FlowManager from 0x01\n\npub fun main(name: String, managerAccount: Address):Address? {\n    let manager = getAccount(managerAccount)\n    let linkPath = FlowManager.contractManagerPath\n    let contractManager = manager\n                        .getCapability(linkPath)\n                        .borrow<&FlowManager.Mapper>()!\n\n    return contractManager.getAddress(name)\n\n}\n";var fe=X;const me=function(){try{return Promise.resolve(n().get("SERVICE_ADDRESS")).then(x)}catch(e){return Promise.reject(e)}},de=function(){try{return Promise.resolve(me()).then(function(e){return Promise.resolve(function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(se,t,"checkManager =>"),u(se,t)})}catch(e){return Promise.reject(e)}}({FlowManager:e})).then(function(e){const n=function(n,t){try{var r=Promise.resolve(O({code:e,service:!0})).then(function(){})}catch(e){return t()}return r&&r.then?r.then(void 0,t):r}(0,function(){return Promise.resolve(function(){try{return Promise.resolve(fe.initManagerTemplate()).then(function(e){return Promise.resolve(function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(ce,t,"FlowManager =>"),u(ce,t)})}catch(e){return Promise.reject(e)}}()).then(function(n){const t=ne(n);return Promise.resolve(R({code:e,args:[t],service:!0})).then(function(){})})})}catch(e){return Promise.reject(e)}}()).then(function(){})});return n&&n.then?n.then(function(){return me()}):me()})})}catch(e){return Promise.reject(e)}},ge=function(){try{return Promise.resolve(de()).then(function(e){return Promise.resolve(function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(ue,t,"getBlockOffset =>"),u(ue,t)})}catch(e){return Promise.reject(e)}}({FlowManager:e})).then(function(e){return O({code:e})})})}catch(e){return Promise.reject(e)}},he=function(e){try{return Promise.resolve(de()).then(function(n){const t=[e];return Promise.resolve(fe.setBlockOffsetTemplate({FlowManager:n})).then(function(e){return R({code:e,args:t,payer:[n]})})})}catch(e){return Promise.reject(e)}},pe=function(e,n=!1){try{if(n){const n=xe[e];if(void 0!==n)return Promise.resolve(n)}return Promise.resolve(de()).then(function(n){const t={FlowManager:n};let r;const c=function(c,s){try{var l=Promise.resolve(function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(le,t,"getContractAddress =>"),u(le,t)})}catch(e){return Promise.reject(e)}}(t)).then(function(t){return Promise.resolve(O({code:t,args:[[e,o.String],[n,o.Address]],service:!0})).then(function(e){r=e})})}catch(e){return s(e)}return l&&l.then?l.then(void 0,s):l}(0,function(e){console.error("failed to get account address:",e)});return c&&c.then?c.then(function(){return r}):r})}catch(e){return Promise.reject(e)}};function Pe(e,n,t){if(!e.s){if(t instanceof Me){if(!t.s)return void(t.o=Pe.bind(null,e,n));1&n&&(n=t.s),t=t.v}if(t&&t.then)return void t.then(Pe.bind(null,e,n),Pe.bind(null,e,2));e.s=n,e.v=t;const r=e.o;r&&r(e)}}const ve=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,Me=function(){function e(){}return e.prototype.then=function(n,t){const r=new e,o=this.s;if(o){const e=1&o?n:t;if(e){try{Pe(r,1,e(this.v))}catch(e){Pe(r,2,e)}return r}return this}return this.o=function(e){try{const o=e.v;1&e.s?Pe(r,1,n?n(o):o):t?Pe(r,1,t(o)):Pe(r,2,o)}catch(e){Pe(r,2,e)}},r},e}(),Ae=e=>e.split(/\s/).map(e=>e.replace(/\s/g,"")).filter(e=>e.length>0&&"import"!==e&&"from"!==e),be=(e,n)=>{const[t,r]=n;return e[t]=r,e},ye=e=>e&&0!==e.length?e.split("\n").filter(e=>e.includes("import")).map(Ae).reduce(be,{}):{},ke=(e,n,t=!0)=>e.replace(ve,(e,r,o,c,s)=>{const a=t?o:s;return`${r}${o} from ${n instanceof Function?n(a):n[a]}`}),we=function(e){try{const n={},t=function(e,t,r){var o=[];for(var c in e)o.push(c);return function(e,n,t){var r,o,c=-1;return function t(s){try{for(;++c<e.length;)if((s=n(c))&&s.then){if(!((a=s)instanceof Me&&1&a.s))return void s.then(t,o||(o=Pe.bind(null,r=new Me,2)));s=s.v}r?Pe(r,1,s):r=s}catch(e){Pe(r||(r=new Me),2,e)}var a}(),r}(o,function(e){return function(e){const t=function(){if(!xe[e])return Promise.resolve(pe(e)).then(function(t){n[e]=t});n[e]=xe[e]}();if(t&&t.then)return t.then(function(){})}(o[e])})}(ye(e));return Promise.resolve(t&&t.then?t.then(function(){return n}):n)}catch(e){return Promise.reject(e)}},xe={FlowToken:"0x0ae53cb6e3f42a79",FungibleToken:"0xee82856bf20e2aa6",FlowFees:"0xe5a8b7f23e8b548f",FlowStorageFees:"0xf8d6e0586b0a20c7"},Se={"0xe5a8b7f23e8b548f":"0xe5a8b7f23e8b548f","0xf8d6e0586b0a20c7":"0xf8d6e0586b0a20c7","0x0ae53cb6e3f42a79":"0x0ae53cb6e3f42a79","0xee82856bf20e2aa6":"0xee82856bf20e2aa6"},Te=function(e,t="transactions"){try{return Promise.resolve(n().get("BASE_PATH")).then(function(n){let o=n;if(j(n)){const c=n[t];if(c)return r.resolve(c,`./${e}.cdc`);o=n.base}return r.resolve(o,`./${t}/${e}.cdc`)})}catch(e){return Promise.reject(e)}},Fe=(e,n={},r=!1)=>{const o=(e=>t.readFileSync(e,"utf8"))(e);return n?ke(o,{...r?Se:xe,...n}):o},je=function({name:e,addressMap:n}){try{return Promise.resolve(Te(e,"contracts")).then(function(e){return Fe(e,n)})}catch(e){return Promise.reject(e)}},Ee=function({name:e,addressMap:n}){try{return Promise.resolve(Te(e,"transactions")).then(function(e){return Fe(e,n)})}catch(e){return Promise.reject(e)}},Be=function({name:e,addressMap:n}){try{return Promise.resolve(Te(e,"scripts")).then(function(e){return Fe(e,n)})}catch(e){return Promise.reject(e)}},Ce={ExampleToken:xe.FlowToken},Ie=e=>e[0].toLowerCase()+e.slice(1),Re=function(e){try{return Promise.resolve(function(e){try{return Promise.resolve(function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(ie,t,"getBalance =>"),u(ie,t)})}catch(e){return Promise.reject(e)}}(Ce)).then(function(n){return n.replace(/(ExampleToken)/gi,n=>"ExampleToken"===n?e:Ie(e))})}catch(e){return Promise.reject(e)}}("FlowToken")).then(function(n){const t=ke(n,xe);return O({code:t,args:[[e,o.Address]]})})}catch(e){return Promise.reject(e)}},Oe=function(e,n){try{return Promise.resolve(function(e){try{return Promise.resolve(fe.mintTokensTemplate(Ce)).then(function(n){return n.replace(/(ExampleToken)/gi,n=>"ExampleToken"===n?e:Ie(e))})}catch(e){return Promise.reject(e)}}("FlowToken")).then(function(t){const r=ke(t,xe);return R({code:r,args:[[e,o.Address],[n,o.UFix64]]})})}catch(e){return Promise.reject(e)}};function Ue(e,n){try{var t=e()}catch(e){return n(e)}return t&&t.then?t.then(void 0,n):t}const $e=function(e){try{const t=e||`deployment-account-${(Math.random()*Math.pow(10,8)).toFixed(0)}`;return Promise.resolve(de()).then(function(e){function r(){const r=function(){if(null===s){const r=Ue(function(){return Promise.resolve(fe.createAccountTemplate(c)).then(function(r){return Promise.resolve(function(){try{const e=S.keyFromPrivate,t=Buffer,r=t.from;return Promise.resolve(n().get("PRIVATE_KEY")).then(function(n){const o=e.call(S,r.call(t,n,"hex")).getPublic("hex").replace(/^04/,"");return M.encode([Buffer.from(o,"hex"),2,3,1e3]).toString("hex")})}catch(e){return Promise.reject(e)}}()).then(function(n){return Promise.resolve(R({code:r,args:[[t,n,o.String],[e,o.Address]]})).then(function({events:e}){const n=e.find(e=>e.type.includes("AccountAdded"));s=n.data.address})})})},function(e){console.error(e)});if(r&&r.then)return r.then(function(){})}}();return r&&r.then?r.then(function(){return s}):s}const c={FlowManager:e};let s;const l=Ue(function(){return Promise.resolve(function(e={}){try{return Promise.resolve(a()).then(function(n){const t={...n,...e};return i(ae,t,"getAccountAddress =>"),u(ae,t)})}catch(e){return Promise.reject(e)}}(c)).then(function(n){return Promise.resolve(O({code:n,args:[[t,o.String],[e,o.Address]],service:!0})).then(function(e){s=e})})},function(e){console.error("failed to get account address:",e)});return l&&l.then?l.then(r):r()})}catch(e){return Promise.reject(e)}},{expect:_e}=global,De=function(e){try{let t;function n(n){return t?n:Promise.resolve(e)}const r=function(){if("function"==typeof e)return t=1,Promise.resolve(e())}();return Promise.resolve(r&&r.then?r.then(n):n(r))}catch(e){return Promise.reject(e)}},Le=function(e){try{const n=De(e);return Promise.resolve(_e(n).resolves.not.toBe(null)).then(function(){return Promise.resolve(_e(n).resolves.not.toThrow()).then(function(){return n.then(({status:e,errorMessage:n})=>{_e(e).toBe(4),_e(n).toBe("")}),n})})}catch(e){return Promise.reject(e)}},He=function(e){try{const n=De(e);return Promise.resolve(_e(n).resolves.not.toThrow()).then(function(){return n})}catch(e){return Promise.reject(e)}},Ge=function(e){try{const n=De(e);return Promise.resolve(_e(n).rejects.not.toBe(null)).then(function(){})}catch(e){return Promise.reject(e)}},Ke=function(e){try{const n=De(e);return Promise.resolve(_e(n).rejects.not.toBe(null)).then(function(){return Promise.resolve(_e(n).rejects.toThrow()).then(function(){})})}catch(e){return Promise.reject(e)}},Ve=function(e){try{function n(){return t.replace(/getCurrentBlock\(\).height/g,"FlowManager.getBlockHeight()")}let t=e;const r=function(){if(!((e,n)=>new RegExp("import\\s+FlowManager").test(n))(0,e))return Promise.resolve(function(){try{return Promise.resolve(me()).then(function(e){return`import FlowManager from ${e}`})}catch(e){return Promise.reject(e)}}()).then(function(n){t=`\n      ${n}\n      ${e}  \n  `})}();return Promise.resolve(r&&r.then?r.then(n):n())}catch(e){return Promise.reject(e)}},{spawn:ze}=require("child_process");var Ne=new class{constructor(){this.initialized=!1,this.logging=!1,this.logProcessor=e=>e}setLogging(e){this.logging=e}log(e,n="log"){this.logging&&console[n](e)}extractKeyValue(e){const[n,t]=e.split("=");return t.includes("LOG")?{key:n,value:t.replace('"[1;34m','"[1[34m')}:{key:n,value:t}}parseDataBuffer(e){const n=e.toString().match(/((\w+=\w+)|(\w+=".*?"))/g);return n?n.map(e=>e.replace(/"/g,"")).reduce((e,n)=>{const{key:t,value:r}=this.extractKeyValue(n);return e[t]=r,e},{}):{}}start(e=8080,n=!1){try{const t=this;let r=e-8080+3569;return t.logging=n,t.filters=[],t.process=ze("flow",["emulator","-v","--http-port",e,"--port",r]),t.logProcessor=e=>e,Promise.resolve(new Promise((e,n)=>{t.process.stdout.on("data",n=>{if(t.filters.length>0){for(let e=0;e<t.filters.length;e++)if(n.includes(`${t.filters[e]}`)){t.log(`LOG: ${n}`);break}}else t.log(`LOG: ${n}`);n.includes("Starting HTTP server")&&(t.log("EMULATOR IS UP! Listening for events!"),t.initialized=!0,e(!0))}),t.process.stderr.on("data",e=>{t.log(`ERROR: ${e}`,"error"),t.initialized=!1,n()}),t.process.on("close",n=>{t.log(`emulator exited with code ${n}`),t.initialized=!1,e(!1)})}))}catch(e){return Promise.reject(e)}}clearFilters(){this.filters=[]}removeFilter(e){this.filters=this.filters(n=>n!==e)}addFilter(e){this.filters.includes(e)||this.filters.push(e)}stop(){try{const e=this;return Promise.resolve(new Promise(n=>{e.process.kill(),setTimeout(()=>{e.initialized=!1,n(!1)},50)}))}catch(e){return Promise.reject(e)}}};export{Ve as builtInMethods,oe as deployContract,re as deployContractByName,Ne as emulator,O as executeScript,ye as extractImports,$e as getAccountAddress,ge as getBlockOffset,y as getConfigValue,pe as getContractAddress,je as getContractCode,Re as getFlowBalance,Be as getScriptCode,me as getServiceAddress,Fe as getTemplate,Ee as getTransactionCode,k as init,Oe as mintFlow,De as promise,ke as replaceImportAddresses,we as resolveImports,R as sendTransaction,b as set,he as setBlockOffset,Le as shallPass,He as shallResolve,Ge as shallRevert,Ke as shallThrow};
//# sourceMappingURL=index.module.js.map
