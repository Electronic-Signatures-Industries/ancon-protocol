import{config as n}from"@onflow/config";import*as t from"@onflow/types";import*as r from"@onflow/fcl";const e={emulator:{FlowToken:"0xee82856bf20e2aa6",FungibleToken:"0x0ae53cb6e3f42a79"},testnet:{FlowToken:"0x7e60df042a9c0868",FungibleToken:"0x9a0766d93b6608b7",LockedTokens:"0x95e019a17d0e23d7",StakingProxy:"0x7aad92e5a0715d21",FUSD:"0xe223d8a629e49c68"},mainnet:{FlowToken:"0x1654653399040a61",FungibleToken:"0xf233dcee88fe0abe",LockedTokens:"0x8d0e87b65159ae63",StakingProxy:"0x62430cf28c26d095",FUSD:"0x3c5959b568896393"}},o={mainnet:"https://access-mainnet-beta.onflow.org",testnet:"https://access-testnet.onflow.org",emulator:"http://localhost:8080"},c=function(){try{return Promise.resolve(n().get("ix.env")).then(function(n){return e[n]||e.emulator})}catch(n){return Promise.reject(n)}},s=function(t="emulator",r={}){try{const c=t.toLowerCase();if(!e[c])throw new Error(`Provided value "${c}" is not supported. Try "emulator", "testnet" or "mainnet". Default: "emulator"`);const{port:s,endpoint:a,limit:u}=r,i="emulator"===c&&s?`http://localhost:${s}`:o[c],f=a||i;return Promise.resolve(n().put("ix.env",c)).then(function(){function t(){return Promise.resolve(n().put("accessNode.api",f)).then(function(){})}const r=function(){if(u)return Promise.resolve(n().put("ix.executionLimit",u)).then(function(){})}();return r&&r.then?r.then(t):t()})}catch(n){return Promise.reject(n)}},a=n=>n.split(/\s/).map(n=>n.replace(/\s/g,"")).filter(n=>n.length>0&&"import"!==n&&"from"!==n),u=(n,t)=>{const[r,e]=t;return n[r]=e,n},i=n=>n&&0!==n.length?n.split("\n").filter(n=>n.includes("import")).map(a).reduce(u,{}):{},f=(n,t={})=>{const r=i(n),e=[];for(const n in r)!t[n]&&Object.prototype.hasOwnProperty.call(r,n)&&e.push(n);return e},d=(n=[],t="")=>{const r="Missing imports for contracts:";console.error(t?`${t} ${r}`:r,n)},l=(n,t,r="")=>{const e=f(n,t);e.length>0&&d(e,r)},m=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,p=(n,t,r=!0)=>n.replace(m,(n,e,o,c,s)=>{const a=r?o:s;return`${e}${o} from ${(t instanceof Function?t(a):t[a])||s}`}),g=n=>{const[t]=n.split("");return t.toUpperCase()+n.slice(1)},w=n=>n.replace(/-/g,"_").split("_").map((n,t)=>t>0?g(n):n).join(""),x=(n,t,r)=>r?n.replace(t,"").split(r):n.replace(t,"").split(h(n)),h=n=>{switch(!0){case n.indexOf("//")>=0:return"//";case n.indexOf("/")>=0:return"/";case n.indexOf("\\")>=0:return"\\";default:return""}},y=n=>n.replace(/\s+/g," "),P="contract",$="transaction",b="script",S=n=>n.split(",").map(n=>n.replace(/\s*/g,"")).filter(n=>""!==n),k=n=>n.replace(/(\/\*[\s\S]*?\*\/)|(\/\/.*)/g,""),F=(n,t)=>{const r=k(n),e=y(r.replace(/[\n\r]/g,""));if(e){const n=new RegExp(t,"g").exec(e);if(n)return""===n[1]?[]:S(n[1])}return[]},v=n=>F(n,"(?:prepare\\s*\\(\\s*)([^\\)]*)(?:\\))"),E=n=>F(n,"(?:fun\\s+main\\s*\\(\\s*)([^\\)]*)(?:\\))"),T=n=>F(n,"(?:transaction\\s*\\(\\s*)([^\\)]*)(?:\\))"),A=n=>{const t=k(n).replace(/\r\n|\n|\r/g," "),r=/\w+\s+contract\s+(?:interface)*\s*(\w*)/g.exec(t);if(r.length<2)throw new Error("Contract Error: can't find name of the contract");return r[1]},N=n=>{const t=k(n).replace(/(resource|struct)\s+\w+\s*{[\s\S]+?}/g,""),r=/(?:access\(\w+\)|pub)\s+contract\s+(?:interface)*\s*(\w*)(\s*{[.\s\S]*init\s*\((.*?)\)[.\s\S]*})?/g.exec(t);if(r.length<2)throw new Error("Contract Error: can't find name of the contract");return{contractName:r[1],args:r[3]||""}},I=n=>{const t=k(n);if(/transaction\s*(\(\s*\))*\s*/g.test(t)){const n=v(t),r=T(t);return{type:"transaction",signers:n.length,args:r}}if(/pub\s+fun\s+main\s*/g.test(t))return{type:"script",args:E(t)};if(/\w+\s+contract\s+(\w*\s*)\w*/g.test(t)){const{contractName:n,args:r}=N(t);return{type:"contract",signers:1,args:r,contractName:n}}return{type:"unknown"}},L=n=>!n||"string"!=typeof n,U=n=>!L(n)&&(n.startsWith("Int")||n.startsWith("UInt")||n.startsWith("Word")),_=n=>{if(L(n))return!1;const t=n.replace(/\s/g,"");return t.startsWith("[")&&t.endsWith("]")},C=n=>{if(L(n))return!1;const t=n.replace(/\s/g,"");return t.startsWith("{")&&t.endsWith("}")},D=n=>_(n)||C(n),M=n=>n.split(/(\w+)\s*:\s*([\w{}[\]:\s?]*)/).filter(n=>""!==n).map(n=>n.replace(/\s*/g,"")),j=n=>M(n)[1],B=n=>/{(.*)}/.exec(n)[1].split(/([^:]*):(.*)/).map(n=>n.replace(/\s/g,"")).filter(n=>n),H=n=>/\[(.*)\]/.exec(n)[1].replace(/\s+/g,""),O=(n,t,r="")=>{if(t>n){const e=`Incorrect number of arguments: found ${n} of ${t}`;console.error(r?`${r} ${e}`:e)}},R=(n="items",t,r,e="")=>{if(r!==t){const o=`Incorrect number of ${n}: found ${t} of ${r}`;console.error(e?`${e} ${o}`:o)}},q=n=>!L(n)&&(n.includes("?")?t.Optional(t[(n=>n.slice(0,-1))(n)]):t[n]),z=n=>{if(D(n))switch(!0){case _(n):{const r=H(n);return t.Array(z(r))}case C(n):{const[r,e]=B(n),o={key:z(r),value:z(e)};return t.Dictionary(o)}default:return q(n)}return q(n)},W=(n,t)=>{const e=z(n);switch(!0){case(n=>{if(L(n))return!1;let t=n.endsWith("?")?n.slice(0,-1):n;return U(t)||(n=>"String"===n)(t)||(n=>"Character"===n)(t)||(n=>"Bool"===n)(t)})(n):return r.arg(t,e);case(n=>!L(n)&&(n.startsWith("Fix64")||n.startsWith("UFix64")))(n):return null===t?r.arg(null,e):(isNaN(parseFloat(t))&&(n=>{throw new Error("Type Error: Expected proper value for fixed type")})(),r.arg(parseFloat(t).toFixed(8),e));case(n=>"Address"===n||"Address?"===n)(n):{const n=null==(o=t)?null:"0x"+(n=>null==n?null:n.replace(/^0x/,""))(o);return r.arg(n,e)}case _(n):{const o=H(n);if(D(o)){const n=t.map(n=>W(o,n).value);return r.arg(n,e)}return r.arg(t,e)}case C(n):{const[o,c]=B(n),s=[],a=Object.keys(t);for(let n=0;n<a.length;n++){const r=a[n];let e;e=D(c)?W(c,t[r]).value:t[r];const u=U(o)?parseInt(r):r;s.push({key:u,value:e})}return r.arg(s,e)}default:throw`${n} is not supported`}var o},G=(n=[],t)=>{if(t.length<n.length)throw new Error("Not enough arguments");return t.map((t,r)=>{const e=W(n[r],t);var o;return(o=e).xform.asArgument(o.value),e})},J=(n,t=[])=>{const r=I(n).args.map(j);return G(r,t)};function K(n,t){try{var r=n()}catch(n){return t(n)}return r&&r.then?r.then(void 0,t):r}const Q=function(t,e){try{const{code:o,cadence:c,args:s,addressMap:a,limit:u,processed:i}=t,f=o||c,d=i?f:p(f,a),l="script"===e?[r.script(d)]:[r.transaction(d)];return s&&l.push(r.args(((n,t)=>{if(0===n.length)return[];const e=n[0];return Array.isArray(e)&&e[e.length-1].asArgument?(n=>n.reduce((n,t)=>[...n,...((n,t)=>{const e=n[n.length-1];return n.slice(0,-1).map(n=>((n,t)=>r.arg(n,t))(n,e))})(t)],[]))(n):J(t,n)})(s,o))),Promise.resolve(n().get("ix.executionLimit")).then(function(n){if(l.push(r.limit(u||n||100)),"transaction"===e){const{proposer:n,payer:e,signers:o=[]}=t,c=0===o.length?[e]:o,s=n||e;l.push(r.payer(e)),l.push(r.proposer(s)),l.push(r.authorizations(c))}return r.send(l)})}catch(n){return Promise.reject(n)}},V=function(n){try{const{raw:t=!1}=n;return Promise.resolve(K(function(){return Promise.resolve(Q(n,"script")).then(function(n){return t?[n.encodedData,null]:Promise.resolve(r.decode(n)).then(function(n){return[n,null]})})},function(n){return[null,n.message]}))}catch(n){return Promise.reject(n)}},X=function(n){try{const{wait:t="seal"}=n;return Promise.resolve(K(function(){return Promise.resolve(Q(n,"transaction")).then(function(n){let e;function o(t){return e?t:[n.transactionId,null]}const c=function(){if(t){const o=(n=>{if("string"==typeof n){const t=n.toLowerCase();if(t.includes("final"))return"onceFinalized";if(t.includes("exec"))return"onceExecuted";if(t.includes("seal"))return"onceExecuted"}return console.log(`‚ö†Ô∏è [33mStatus value [1m[35m"${n}"[33m[2m is not supported. Reverting to [32m"onceSealed"[0m`),"onceSealed"})(t);return Promise.resolve(r.tx(n)[o]()).then(function(t){const r={txId:n,...t};return e=1,[r,null]})}}();return c&&c.then?c.then(o):o(c)})},function(n){return[null,n.message]}))}catch(n){return Promise.reject(n)}},Y=function(n){try{const{name:t,to:r,payer:e,proposer:o,code:c,update:s=!1,processed:a=!1,addressMap:u={}}=n,i=a?c:p(c,u),f=s?"\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  ":"\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n",d=Buffer.from(i,"utf8").toString("hex");let l=r,m=r;return e&&(m=e,l=o||e),X({payer:m,proposer:l,signers:[r],code:f,args:[t,d]})}catch(n){return Promise.reject(n)}},Z=function(n){try{return Y({...n,update:!0})}catch(n){return Promise.reject(n)}};export{P as CONTRACT,b as SCRIPT,$ as TRANSACTION,j as argType,g as capitalizeFirstLetter,y as collapseSpaces,Y as deployContract,V as executeScript,F as extract,A as extractContractName,N as extractContractParameters,i as extractImports,E as extractScriptArguments,v as extractSigners,T as extractTransactionArguments,S as generateSchema,H as getArrayType,B as getDictionaryTypes,c as getEnvironment,h as getSplitCharacter,I as getTemplateInfo,W as mapArgument,G as mapArguments,J as mapValuesToCode,f as missingImports,X as mutate,V as query,p as replaceImportAddresses,d as report,O as reportArguments,R as reportMissing,l as reportMissingImports,X as sendTransaction,s as setEnvironment,M as splitArgs,x as trimAndSplit,w as underscoreToCamelCase,Z as updateContract};
//# sourceMappingURL=main.module.js.map
