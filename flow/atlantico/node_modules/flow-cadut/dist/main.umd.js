!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@onflow/config"),require("@onflow/types"),require("@onflow/fcl")):"function"==typeof define&&define.amd?define(["exports","@onflow/config","@onflow/types","@onflow/fcl"],t):t((n||self).flowCadut={},n.config,n.t,n.fcl)}(this,function(n,t,e,r){function o(n){if(n&&n.o)return n;var t=Object.create(null);return n&&Object.keys(n).forEach(function(e){if("default"!==e){var r=Object.getOwnPropertyDescriptor(n,e);Object.defineProperty(t,e,r.get?r:{enumerable:!0,get:function(){return n[e]}})}}),t.default=n,t}var c=o(e),s=o(r);const u={emulator:{FlowToken:"0xee82856bf20e2aa6",FungibleToken:"0x0ae53cb6e3f42a79"},testnet:{FlowToken:"0x7e60df042a9c0868",FungibleToken:"0x9a0766d93b6608b7",LockedTokens:"0x95e019a17d0e23d7",StakingProxy:"0x7aad92e5a0715d21",FUSD:"0xe223d8a629e49c68"},mainnet:{FlowToken:"0x1654653399040a61",FungibleToken:"0xf233dcee88fe0abe",LockedTokens:"0x8d0e87b65159ae63",StakingProxy:"0x62430cf28c26d095",FUSD:"0x3c5959b568896393"}},a={mainnet:"https://access-mainnet-beta.onflow.org",testnet:"https://access-testnet.onflow.org",emulator:"http://localhost:8080"},i=n=>n.split(/\s/).map(n=>n.replace(/\s/g,"")).filter(n=>n.length>0&&"import"!==n&&"from"!==n),f=(n,t)=>{const[e,r]=t;return n[e]=r,n},d=n=>n&&0!==n.length?n.split("\n").filter(n=>n.includes("import")).map(i).reduce(f,{}):{},l=(n,t={})=>{const e=d(n),r=[];for(const n in e)!t[n]&&Object.prototype.hasOwnProperty.call(e,n)&&r.push(n);return r},m=(n=[],t="")=>{const e="Missing imports for contracts:";console.error(t?`${t} ${e}`:e,n)},p=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,g=(n,t,e=!0)=>n.replace(p,(n,r,o,c,s)=>{const u=e?o:s;return`${r}${o} from ${(t instanceof Function?t(u):t[u])||s}`}),w=n=>{const[t]=n.split("");return t.toUpperCase()+n.slice(1)},x=n=>{switch(!0){case n.indexOf("//")>=0:return"//";case n.indexOf("/")>=0:return"/";case n.indexOf("\\")>=0:return"\\";default:return""}},h=n=>n.replace(/\s+/g," "),y="contract",b="transaction",P="script",$=n=>n.split(",").map(n=>n.replace(/\s*/g,"")).filter(n=>""!==n),v=n=>n.replace(/(\/\*[\s\S]*?\*\/)|(\/\/.*)/g,""),S=(n,t)=>{const e=v(n),r=h(e.replace(/[\n\r]/g,""));if(r){const n=new RegExp(t,"g").exec(r);if(n)return""===n[1]?[]:$(n[1])}return[]},k=n=>S(n,"(?:prepare\\s*\\(\\s*)([^\\)]*)(?:\\))"),F=n=>S(n,"(?:fun\\s+main\\s*\\(\\s*)([^\\)]*)(?:\\))"),E=n=>S(n,"(?:transaction\\s*\\(\\s*)([^\\)]*)(?:\\))"),T=n=>{const t=v(n).replace(/(resource|struct)\s+\w+\s*{[\s\S]+?}/g,""),e=/(?:access\(\w+\)|pub)\s+contract\s+(?:interface)*\s*(\w*)(\s*{[.\s\S]*init\s*\((.*?)\)[.\s\S]*})?/g.exec(t);if(e.length<2)throw new Error("Contract Error: can't find name of the contract");return{contractName:e[1],args:e[3]||""}},j=n=>{const t=v(n);if(/transaction\s*(\(\s*\))*\s*/g.test(t)){const n=k(t),e=E(t);return{type:b,signers:n.length,args:e}}if(/pub\s+fun\s+main\s*/g.test(t)){const n=F(t);return{type:P,args:n}}if(/\w+\s+contract\s+(\w*\s*)\w*/g.test(t)){const{contractName:n,args:e}=T(t);return{type:y,signers:1,args:e,contractName:n}}return{type:"unknown"}},A=n=>!n||"string"!=typeof n,N=n=>!A(n)&&(n.startsWith("Int")||n.startsWith("UInt")||n.startsWith("Word")),I=n=>{if(A(n))return!1;const t=n.replace(/\s/g,"");return t.startsWith("[")&&t.endsWith("]")},O=n=>{if(A(n))return!1;const t=n.replace(/\s/g,"");return t.startsWith("{")&&t.endsWith("}")},L=n=>I(n)||O(n),U=n=>n.split(/(\w+)\s*:\s*([\w{}[\]:\s?]*)/).filter(n=>""!==n).map(n=>n.replace(/\s*/g,"")),_=n=>U(n)[1],q=n=>/{(.*)}/.exec(n)[1].split(/([^:]*):(.*)/).map(n=>n.replace(/\s/g,"")).filter(n=>n),C=n=>/\[(.*)\]/.exec(n)[1].replace(/\s+/g,""),D=n=>!A(n)&&(n.includes("?")?c.Optional(c[(n=>n.slice(0,-1))(n)]):c[n]),M=n=>{if(L(n))switch(!0){case I(n):{const t=C(n);return c.Array(M(t))}case O(n):{const[t,e]=q(n),r={key:M(t),value:M(e)};return c.Dictionary(r)}default:return D(n)}return D(n)},B=(n,t)=>{const e=M(n);switch(!0){case(n=>{if(A(n))return!1;let t=n.endsWith("?")?n.slice(0,-1):n;return N(t)||(n=>"String"===n)(t)||(n=>"Character"===n)(t)||(n=>"Bool"===n)(t)})(n):return s.arg(t,e);case(n=>!A(n)&&(n.startsWith("Fix64")||n.startsWith("UFix64")))(n):return null===t?s.arg(null,e):(isNaN(parseFloat(t))&&(n=>{throw new Error("Type Error: Expected proper value for fixed type")})(),s.arg(parseFloat(t).toFixed(8),e));case(n=>"Address"===n||"Address?"===n)(n):{const n=null==(r=t)?null:"0x"+(n=>null==n?null:n.replace(/^0x/,""))(r);return s.arg(n,e)}case I(n):{const r=C(n);if(L(r)){const n=t.map(n=>B(r,n).value);return s.arg(n,e)}return s.arg(t,e)}case O(n):{const[r,o]=q(n),c=[],u=Object.keys(t);for(let n=0;n<u.length;n++){const e=u[n];let s;s=L(o)?B(o,t[e]).value:t[e];const a=N(r)?parseInt(e):e;c.push({key:a,value:s})}return s.arg(c,e)}default:throw`${n} is not supported`}var r},H=(n=[],t)=>{if(t.length<n.length)throw new Error("Not enough arguments");return t.map((t,e)=>{const r=B(n[e],t);var o;return(o=r).xform.asArgument(o.value),r})},R=(n,t=[])=>{const e=j(n).args.map(_);return H(e,t)};function z(n,t){try{var e=n()}catch(n){return t(n)}return e&&e.then?e.then(void 0,t):e}const W=function(n,e){try{const{code:r,cadence:o,args:c,addressMap:u,limit:a,processed:i}=n,f=r||o,d=i?f:g(f,u),l="script"===e?[s.script(d)]:[s.transaction(d)];return c&&l.push(s.args(((n,t)=>{if(0===n.length)return[];const e=n[0];return Array.isArray(e)&&e[e.length-1].asArgument?(n=>n.reduce((n,t)=>[...n,...((n,t)=>{const e=n[n.length-1];return n.slice(0,-1).map(n=>((n,t)=>s.arg(n,t))(n,e))})(t)],[]))(n):R(t,n)})(c,r))),Promise.resolve(t.config().get("ix.executionLimit")).then(function(t){if(l.push(s.limit(a||t||100)),"transaction"===e){const{proposer:t,payer:e,signers:r=[]}=n,o=0===r.length?[e]:r,c=t||e;l.push(s.payer(e)),l.push(s.proposer(c)),l.push(s.authorizations(o))}return s.send(l)})}catch(n){return Promise.reject(n)}},G=function(n){try{const{raw:t=!1}=n;return Promise.resolve(z(function(){return Promise.resolve(W(n,"script")).then(function(n){return t?[n.encodedData,null]:Promise.resolve(s.decode(n)).then(function(n){return[n,null]})})},function(n){return[null,n.message]}))}catch(n){return Promise.reject(n)}},J=function(n){try{const{wait:t="seal"}=n;return Promise.resolve(z(function(){return Promise.resolve(W(n,"transaction")).then(function(n){let e;function r(t){return e?t:[n.transactionId,null]}const o=function(){if(t){const r=(n=>{if("string"==typeof n){const t=n.toLowerCase();if(t.includes("final"))return"onceFinalized";if(t.includes("exec"))return"onceExecuted";if(t.includes("seal"))return"onceExecuted"}return console.log(`âš ï¸ [33mStatus value [1m[35m"${n}"[33m[2m is not supported. Reverting to [32m"onceSealed"[0m`),"onceSealed"})(t);return Promise.resolve(s.tx(n)[r]()).then(function(t){const r={txId:n,...t};return e=1,[r,null]})}}();return o&&o.then?o.then(r):r(o)})},function(n){return[null,n.message]}))}catch(n){return Promise.reject(n)}},K=function(n){try{const{name:t,to:e,payer:r,proposer:o,code:c,update:s=!1,processed:u=!1,addressMap:a={}}=n,i=u?c:g(c,a),f=s?"\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  ":"\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n",d=Buffer.from(i,"utf8").toString("hex");let l=e,m=e;return r&&(m=r,l=o||r),J({payer:m,proposer:l,signers:[e],code:f,args:[t,d]})}catch(n){return Promise.reject(n)}};n.CONTRACT=y,n.SCRIPT=P,n.TRANSACTION=b,n.argType=_,n.capitalizeFirstLetter=w,n.collapseSpaces=h,n.deployContract=K,n.executeScript=G,n.extract=S,n.extractContractName=n=>{const t=v(n).replace(/\r\n|\n|\r/g," "),e=/\w+\s+contract\s+(?:interface)*\s*(\w*)/g.exec(t);if(e.length<2)throw new Error("Contract Error: can't find name of the contract");return e[1]},n.extractContractParameters=T,n.extractImports=d,n.extractScriptArguments=F,n.extractSigners=k,n.extractTransactionArguments=E,n.generateSchema=$,n.getArrayType=C,n.getDictionaryTypes=q,n.getEnvironment=function(){try{return Promise.resolve(t.config().get("ix.env")).then(function(n){return u[n]||u.emulator})}catch(n){return Promise.reject(n)}},n.getSplitCharacter=x,n.getTemplateInfo=j,n.mapArgument=B,n.mapArguments=H,n.mapValuesToCode=R,n.missingImports=l,n.mutate=J,n.query=G,n.replaceImportAddresses=g,n.report=m,n.reportArguments=(n,t,e="")=>{if(t>n){const r=`Incorrect number of arguments: found ${n} of ${t}`;console.error(e?`${e} ${r}`:r)}},n.reportMissing=(n="items",t,e,r="")=>{if(e!==t){const o=`Incorrect number of ${n}: found ${t} of ${e}`;console.error(r?`${r} ${o}`:o)}},n.reportMissingImports=(n,t,e="")=>{const r=l(n,t);r.length>0&&m(r,e)},n.sendTransaction=J,n.setEnvironment=function(n="emulator",e={}){try{const r=n.toLowerCase();if(!u[r])throw new Error(`Provided value "${r}" is not supported. Try "emulator", "testnet" or "mainnet". Default: "emulator"`);const{port:o,endpoint:c,limit:s}=e,i="emulator"===r&&o?`http://localhost:${o}`:a[r],f=c||i;return Promise.resolve(t.config().put("ix.env",r)).then(function(){function n(){return Promise.resolve(t.config().put("accessNode.api",f)).then(function(){})}const e=function(){if(s)return Promise.resolve(t.config().put("ix.executionLimit",s)).then(function(){})}();return e&&e.then?e.then(n):n()})}catch(n){return Promise.reject(n)}},n.splitArgs=U,n.trimAndSplit=(n,t,e)=>e?n.replace(t,"").split(e):n.replace(t,"").split(x(n)),n.underscoreToCamelCase=n=>n.replace(/-/g,"_").split("_").map((n,t)=>t>0?w(n):n).join(""),n.updateContract=function(n){try{return K({...n,update:!0})}catch(n){return Promise.reject(n)}}});
//# sourceMappingURL=main.umd.js.map
