import{config as t}from"@onflow/config";import*as n from"@onflow/types";import*as e from"@onflow/fcl";const r={emulator:{FlowToken:"0xee82856bf20e2aa6",FungibleToken:"0x0ae53cb6e3f42a79"},testnet:{FlowToken:"0x7e60df042a9c0868",FungibleToken:"0x9a0766d93b6608b7",LockedTokens:"0x95e019a17d0e23d7",StakingProxy:"0x7aad92e5a0715d21",FUSD:"0xe223d8a629e49c68"},mainnet:{FlowToken:"0x1654653399040a61",FungibleToken:"0xf233dcee88fe0abe",LockedTokens:"0x8d0e87b65159ae63",StakingProxy:"0x62430cf28c26d095",FUSD:"0x3c5959b568896393"}},o={mainnet:"https://access-mainnet-beta.onflow.org",testnet:"https://access-testnet.onflow.org",emulator:"http://localhost:8080"},s=async()=>{const n=await t().get("ix.env")||"emulator";return r[n]||r.emulator},c=async(n="emulator",e={})=>{const s=n.toLowerCase();if(!r[s])throw new Error(`Provided value "${s}" is not supported. Try "emulator", "testnet" or "mainnet". Default: "emulator"`);const{port:c,endpoint:a,limit:i}=e,u=a||("emulator"===s&&c?`http://localhost:${c}`:o[s]);await t().put("ix.env",s),i&&await t().put("ix.executionLimit",i),await t().put("accessNode.api",u)},a=t=>t.split(/\s/).map(t=>t.replace(/\s/g,"")).filter(t=>t.length>0&&"import"!==t&&"from"!==t),i=(t,n)=>{const[e,r]=n;return t[e]=r,t},u=t=>t&&0!==t.length?t.split("\n").filter(t=>t.includes("import")).map(a).reduce(i,{}):{},d=(t,n={})=>{const e=u(t),r=[];for(const t in e)!n[t]&&Object.prototype.hasOwnProperty.call(e,t)&&r.push(t);return r},l=(t=[],n="")=>{const e="Missing imports for contracts:";console.error(n?`${n} ${e}`:e,t)},f=(t,n,e="")=>{const r=d(t,n);r.length>0&&l(r,e)},p=/(\s*import\s*)([\w\d]+)(\s+from\s*)([\w\d".\\/]+)/g,m=(t,n,e=!0)=>t.replace(p,(t,r,o,s,c)=>{const a=e?o:c;return`${r}${o} from ${(n instanceof Function?n(a):n[a])||c}`}),g=t=>{const[n]=t.split("");return n.toUpperCase()+t.slice(1)},w=t=>t.replace(/-/g,"_").split("_").map((t,n)=>n>0?g(t):t).join(""),x=(t,n,e)=>e?t.replace(n,"").split(e):t.replace(n,"").split(y(t)),y=t=>{switch(!0){case t.indexOf("//")>=0:return"//";case t.indexOf("/")>=0:return"/";case t.indexOf("\\")>=0:return"\\";default:return""}},h=t=>t.replace(/\s+/g," "),b="contract",$="transaction",S="script",k=t=>t.split(",").map(t=>t.replace(/\s*/g,"")).filter(t=>""!==t),v=t=>t.replace(/(\/\*[\s\S]*?\*\/)|(\/\/.*)/g,""),F=(t,n)=>{const e=v(t),r=h(e.replace(/[\n\r]/g,""));if(r){const t=new RegExp(n,"g").exec(r);if(t)return""===t[1]?[]:k(t[1])}return[]},E=t=>F(t,"(?:prepare\\s*\\(\\s*)([^\\)]*)(?:\\))"),T=t=>F(t,"(?:fun\\s+main\\s*\\(\\s*)([^\\)]*)(?:\\))"),A=t=>F(t,"(?:transaction\\s*\\(\\s*)([^\\)]*)(?:\\))"),N=t=>{const n=v(t).replace(/\r\n|\n|\r/g," "),e=/\w+\s+contract\s+(?:interface)*\s*(\w*)/g.exec(n);if(e.length<2)throw new Error("Contract Error: can't find name of the contract");return e[1]},I=t=>{const n=v(t).replace(/(resource|struct)\s+\w+\s*{[\s\S]+?}/g,""),e=/(?:access\(\w+\)|pub)\s+contract\s+(?:interface)*\s*(\w*)(\s*{[.\s\S]*init\s*\((.*?)\)[.\s\S]*})?/g.exec(n);if(e.length<2)throw new Error("Contract Error: can't find name of the contract");return{contractName:e[1],args:e[3]||""}},j=t=>{const n=v(t);if(/transaction\s*(\(\s*\))*\s*/g.test(n)){const t=E(n),e=A(n);return{type:"transaction",signers:t.length,args:e}}if(/pub\s+fun\s+main\s*/g.test(n))return{type:"script",args:T(n)};if(/\w+\s+contract\s+(\w*\s*)\w*/g.test(n)){const{contractName:t,args:e}=I(n);return{type:"contract",signers:1,args:e,contractName:t}}return{type:"unknown"}},L=t=>!t||"string"!=typeof t,O=t=>!L(t)&&(t.startsWith("Int")||t.startsWith("UInt")||t.startsWith("Word")),U=t=>{if(L(t))return!1;const n=t.replace(/\s/g,"");return n.startsWith("[")&&n.endsWith("]")},_=t=>{if(L(t))return!1;const n=t.replace(/\s/g,"");return n.startsWith("{")&&n.endsWith("}")},C=t=>U(t)||_(t),D=t=>t.split(/(\w+)\s*:\s*([\w{}[\]:\s?]*)/).filter(t=>""!==t).map(t=>t.replace(/\s*/g,"")),M=t=>D(t)[1],P=t=>/{(.*)}/.exec(t)[1].split(/([^:]*):(.*)/).map(t=>t.replace(/\s/g,"")).filter(t=>t),B=t=>/\[(.*)\]/.exec(t)[1].replace(/\s+/g,""),H=(t,n,e="")=>{if(n>t){const r=`Incorrect number of arguments: found ${t} of ${n}`;console.error(e?`${e} ${r}`:r)}},R=(t="items",n,e,r="")=>{if(e!==n){const o=`Incorrect number of ${t}: found ${n} of ${e}`;console.error(r?`${r} ${o}`:o)}},q=t=>!L(t)&&(t.includes("?")?n.Optional(n[(t=>t.slice(0,-1))(t)]):n[t]),z=t=>{if(C(t))switch(!0){case U(t):{const e=B(t);return n.Array(z(e))}case _(t):{const[e,r]=P(t),o={key:z(e),value:z(r)};return n.Dictionary(o)}default:return q(t)}return q(t)},W=(t,n)=>{const r=z(t);switch(!0){case(t=>{if(L(t))return!1;let n=t.endsWith("?")?t.slice(0,-1):t;return O(n)||(t=>"String"===t)(n)||(t=>"Character"===t)(n)||(t=>"Bool"===t)(n)})(t):return e.arg(n,r);case(t=>!L(t)&&(t.startsWith("Fix64")||t.startsWith("UFix64")))(t):return null===n?e.arg(null,r):(isNaN(parseFloat(n))&&(t=>{throw new Error("Type Error: Expected proper value for fixed type")})(),e.arg(parseFloat(n).toFixed(8),r));case(t=>"Address"===t||"Address?"===t)(t):{const t=null==(o=n)?null:"0x"+(t=>null==t?null:t.replace(/^0x/,""))(o);return e.arg(t,r)}case U(t):{const o=B(t);if(C(o)){const t=n.map(t=>W(o,t).value);return e.arg(t,r)}return e.arg(n,r)}case _(t):{const[o,s]=P(t),c=[],a=Object.keys(n);for(let t=0;t<a.length;t++){const e=a[t];let r;r=C(s)?W(s,n[e]).value:n[e];const i=O(o)?parseInt(e):e;c.push({key:i,value:r})}return e.arg(c,r)}default:throw`${t} is not supported`}var o},G=(t=[],n)=>{if(n.length<t.length)throw new Error("Not enough arguments");return n.map((n,e)=>{const r=W(t[e],n);var o;return(o=r).xform.asArgument(o.value),r})},J=(t,n=[])=>{const e=j(t).args.map(M);return G(e,n)};function K(){return(K=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t}).apply(this,arguments)}const Q=async(n,r)=>{const{code:o,cadence:s,args:c,addressMap:a,limit:i,processed:u}=n,d=o||s,l=u?d:m(d,a),f="script"===r?[e.script(l)]:[e.transaction(l)];c&&f.push(e.args(((t,n)=>{if(0===t.length)return[];const r=t[0];return Array.isArray(r)&&r[r.length-1].asArgument?(t=>t.reduce((t,n)=>[...t,...((t,n)=>{const r=t[t.length-1];return t.slice(0,-1).map(t=>((t,n)=>e.arg(t,n))(t,r))})(n)],[]))(t):J(n,t)})(c,o)));const p=await t().get("ix.executionLimit");if(f.push(e.limit(i||p||100)),"transaction"===r){const{proposer:t,payer:r,signers:o=[]}=n,s=0===o.length?[r]:o,c=t||r;f.push(e.payer(r)),f.push(e.proposer(c)),f.push(e.authorizations(s))}return e.send(f)},V=async t=>{const{raw:n=!1}=t;try{const r=await Q(t,"script");return n?[r.encodedData,null]:[await e.decode(r),null]}catch(t){return[null,t.message]}},X=async t=>{const{wait:n="seal"}=t;try{const r=await Q(t,"transaction");if(n){const t=(t=>{if("string"==typeof t){const n=t.toLowerCase();if(n.includes("final"))return"onceFinalized";if(n.includes("exec"))return"onceExecuted";if(n.includes("seal"))return"onceExecuted"}return console.log(`⚠️ [33mStatus value [1m[35m"${t}"[33m[2m is not supported. Reverting to [32m"onceSealed"[0m`),"onceSealed"})(n);return[K({txId:r},await e.tx(r)[t]()),null]}return[r.transactionId,null]}catch(t){return[null,t.message]}},Y=async t=>{const{name:n,to:e,payer:r,proposer:o,code:s,update:c=!1,processed:a=!1,addressMap:i={}}=t,u=a?s:m(s,i),d=c?"\n    transaction(name: String, code: String) {\n      prepare(acct: AuthAccount){\n        let decoded = code.decodeHex()\n        \n        acct.contracts.add(\n          name: name,\n          code: decoded,\n        )\n      }\n    }\n  ":"\n  transaction(name: String, code: String){\n    prepare(acct: AuthAccount){\n      let decoded = code.decodeHex()\n      \n      if acct.contracts.get(name: name) == nil {\n        acct.contracts.add(name: name, code: decoded)\n      } else {\n        acct.contracts.update__experimental(name: name, code: decoded)\n      }\n    }\n  }\n",l=Buffer.from(u,"utf8").toString("hex");let f=e,p=e;return r&&(p=r,f=o||r),X({payer:p,proposer:f,signers:[e],code:d,args:[n,l]})},Z=async t=>Y(K({},t,{update:!0}));export{b as CONTRACT,S as SCRIPT,$ as TRANSACTION,M as argType,g as capitalizeFirstLetter,h as collapseSpaces,Y as deployContract,V as executeScript,F as extract,N as extractContractName,I as extractContractParameters,u as extractImports,T as extractScriptArguments,E as extractSigners,A as extractTransactionArguments,k as generateSchema,B as getArrayType,P as getDictionaryTypes,s as getEnvironment,y as getSplitCharacter,j as getTemplateInfo,W as mapArgument,G as mapArguments,J as mapValuesToCode,d as missingImports,X as mutate,V as query,m as replaceImportAddresses,l as report,H as reportArguments,R as reportMissing,f as reportMissingImports,X as sendTransaction,c as setEnvironment,D as splitArgs,x as trimAndSplit,w as underscoreToCamelCase,Z as updateContract};
//# sourceMappingURL=main.modern.js.map
